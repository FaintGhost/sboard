# 最佳实践

## OpenAPI Spec 编写

### 1. Schema 复用
- 所有实体定义在 `components/schemas/` 下，通过 `$ref` 引用
- 通用分页参数定义在 `components/parameters/` 下复用
- 通用错误响应定义在 `components/responses/` 下复用

```yaml
components:
  parameters:
    LimitParam:
      name: limit
      in: query
      schema:
        type: integer
        minimum: 0
        maximum: 500
        default: 50
    OffsetParam:
      name: offset
      in: query
      schema:
        type: integer
        minimum: 0
        default: 0

  responses:
    BadRequest:
      description: 请求参数错误
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/ErrorResponse'
    Unauthorized:
      description: 未认证
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/ErrorResponse'
    NotFound:
      description: 资源不存在
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/ErrorResponse'
```

### 2. 命名规范
- **Schema 名称**：PascalCase（`User`, `CreateUserRequest`, `UpdateNodeRequest`）
- **属性名称**：snake_case（`group_ids`, `traffic_limit`），与现有 JSON 格式保持一致
- **Operation ID**：camelCase（`listUsers`, `createUser`, `getUserById`），用于生成函数名
- **Path 参数**：snake_case（`user_uuid`, `id`）

### 3. 安全标注
- 所有需认证的端点标注 `security: [{ BearerAuth: [] }]`
- 公开端点（health, login, bootstrap, subscription）标注 `security: []`
- 在 spec 顶层不设全局 security，逐端点显式标注

## Go 后端 (oapi-codegen)

### 1. Strict Server 模式
- 始终使用 strict-server 模式，确保编译时类型安全
- handler 返回值必须是生成的 Response 类型之一，避免遗漏错误处理
- 利用 Go 编译器确保所有操作都已实现（未实现会编译失败）

### 2. 错误处理模式
```go
// 统一错误返回模式
func (s *Server) GetUser(ctx context.Context, req GetUserRequestObject) (GetUserResponseObject, error) {
    user, err := s.store.GetUserByID(ctx, req.Id)
    if err != nil {
        if errors.Is(err, db.ErrNotFound) {
            return GetUser404JSONResponse{Error: "user not found"}, nil
        }
        return GetUser500JSONResponse{Error: "get user failed"}, nil
    }
    dto := toUserDTO(user)
    return GetUser200JSONResponse{Data: dto}, nil
}
```

注意：业务错误通过返回对应的 HTTP 错误响应类型处理，不使用 Go error（Go error 对应 500 内部错误）。

### 3. 业务逻辑保留
- `toUserDTO`、`toNodeDTO` 等转换函数保留
- `syncNodesForUser`、`trySyncNodeWithSource` 等副作用逻辑保留
- `inbval.ValidateSettings` 等验证逻辑保留
- 只改变 handler 的签名和参数获取方式

### 4. 生成代码管理
- 生成文件以 `.gen.go` 后缀标识
- `.gitignore` 中**不**忽略生成文件（CI 需要检查新鲜度）
- 生成文件添加 `// Code generated by oapi-codegen. DO NOT EDIT.` 头部（工具自动添加）

## TypeScript 前端 (@hey-api/openapi-ts)

### 1. Client 配置分离
- 生成代码放在 `src/lib/api/gen/`，不手动修改
- 自定义配置（auth、error handling、base URL）在 `src/lib/api/client.ts`
- 页面组件只导入 `gen/sdk.gen` 的 SDK 函数和 `gen/types.gen` 的类型

### 2. React Query 集成
- SDK 函数直接用作 React Query 的 `queryFn`
- query key 可基于 operation ID 构建，保持一致性

```typescript
// hooks/use-users.ts
import { listUsers } from "@/lib/api/gen/sdk.gen";

export function useUsers(params?: { status?: string }) {
  return useQuery({
    queryKey: ["listUsers", params],
    queryFn: async () => {
      const { data } = await listUsers({ query: params });
      return data?.data ?? [];
    },
  });
}
```

### 3. Zod 使用策略
- 不对所有 API 响应做运行时校验（性能开销）
- 对表单提交做请求校验（替代手写 Zod schema）
- 在关键路径（如登录、支付）做响应校验

### 4. 类型导入
- 从 `gen/types.gen.ts` 导入类型
- 禁止从非生成文件导出 API 类型（避免漂移）

## 版本管理

### Spec 变更流程
1. 修改 `panel/openapi.yaml`
2. 运行 `make generate`
3. 修改后端 handler 实现（如有新操作或签名变更）
4. 修改前端调用代码（如有新操作或签名变更）
5. 运行全量测试
6. 提交所有变更（spec + 生成代码 + 实现代码）

### 向后兼容
- 新增字段设为 optional（不破坏旧客户端）
- 删除字段需要 deprecated 过渡期（如需要）
- 新增端点不影响现有端点
- 修改端点行为需要同步更新前后端

## 性能考虑

### 代码生成开销
- `oapi-codegen` 生成一次约 1-3 秒
- `@hey-api/openapi-ts` 生成一次约 2-5 秒
- 只在 spec 变更时需要重新生成
- CI 每次构建都做新鲜度检查，不做重新生成

### 运行时开销
- strict-server 的 wrapper 增加极小的函数调用开销
- Zod 校验有一定 CPU 开销，仅在必要路径启用
- 生成的 TypeScript SDK 使用原生 fetch，无额外 runtime 依赖
